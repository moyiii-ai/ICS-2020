# ICSⅠ Lab4 报告

计算机科学与技术
19307130296
孙若诗

qaz

## 运行截图

## 问题解答

* **Task 0**

1. 代码中的错误是什么？
&emsp;&emsp;main.cpp调用了notATest函数，但是some.h头文件里没有声明。

* **Task 1**

1. 为什么两个function.h都引⽤了shared.h⽽没有出问题？本来有可能出什么问题。
&emsp;&emsp;因为shared.h没有定义全局变量。
&emsp;&emsp;本来shared.h定义的全局变量可能会在编译时被重复定义，导致出错。

2. 如果把shared.h中注释掉的变量定义取消注释会出什么问题？为什么？
&emsp;&emsp;会导致编译出错。
&emsp;&emsp;因为它定义了全局变量并且赋了初值，main0.cpp包含了function0.h和function1.h，而这两个头文件都包含了shared.h，这意味着shared.h会被包含两次，定义也就发生了两次；变量定义的重复是不可接受的。

3. 通常使⽤shared.h中另外被注释掉的宏命令(#开头的那些⾏)来规避重复引⽤的⻛险，原理是什么？取消这些注释之后上⼀题的问题解除了吗？不管解没解除背后的原因是什么？
&emsp;&emsp;判断是否定义过这个变量，未定义时才定义，使定义在每个源文件编译时只发生一次。
&emsp;&emsp;上一问在单文件编译时的问题解决了，但是链接时仍旧会出现问题，因为链接过程发生在编译之后，多个源文件共同编译时仍旧会重复定义。

* **Task 2**

1. 若有多个静态链接库需要链接，写命令时需要考虑静态链接库和源⽂件在命令中的顺序吗？是否需要考虑是由什么决定的？

2. 可以使⽤size main命令来查看可执⾏⽂件A所占的空间，输出结果的每⼀项是什么意思？

* **Task 3**

1. 动态链接库在运⾏时也需要查找库的位置，在Linux中，运⾏时动态链接库的查找顺序是怎样的？

2. 使⽤size main查看编译出的可执⾏⽂件占据的空间，与使⽤静态链接库相⽐占⽤空间有何变化？哪些部分的哪些代码（也要具体到本task）会导致编译出⽂件的占⽤空间发⽣这种变化？

3. 编译动态链接库时-fPIC的作⽤是什么，不加会有什么后果？

4. 现在被⼴泛使⽤的公开的动态链接库如何进⾏版本替换或共存（以linux系统为例）？

* **Task 4**

1. 添加的动态链接库分别是什么，起什么作⽤？

2. 动态链接器⼀个操作系统中只需要⼀个吗？为什么？

* **Task 5(H)**

1. 简述这道题的解法。

## 解题记录

* **Task 0**

1. 最大问题：从来没写过.h，现场学习多文件编译过程。重要的是区别开函数的声明、定义和调用。调用是需要有声明或定义的，定义之前原则上应有声明但不必须。
&emsp;&emsp;比如这里main.cpp调用了notATest，但是头文件some.h里没有声明，所以不能编译成功。而test.cpp只是定义notATest，没有调用，所以无声明也可行。由于编译的过程是先分别编译每个c文件，再链接成一个可执行文件，所以只要有一个文件编译不成功就不合法。
2. 注释
井号（#）在Makefile中表示注释。
3. 回声
正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。在命令的前面加上@，就可以关闭回声。由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。
4. 安装make报错:Sub-process /usr/bin/dpkg returned an error code (1)

~~~html
cd /var/lib/dpkg/
sudo mv info/ info_bak          # 现将info文件夹更名
sudo mkdir info                 # 再新建一个新的info文件夹
sudo apt-get update             # 更新
sudo apt-get -f install         # 修复  
sudo mv info/* info_bak/        # 将info下生成文件移到info_bak下
sudo rm -rf info                # 把自己新建的info文件夹删掉
sudo mv info_bak info           # 把以前的info文件夹重新改回名
~~~

5. sh: 0: Can't open TeskAll.sh
不知道为什么。打开了TeskAll.sh的执行权限，重启了终端，再次输入安装make的指令，被告知make已经安装完，就好了。

* **Task 1**

1. 学习了头文件重复包含和重复定义的性质

>&emsp;&emsp;对于重复包含错误，一般使用#ifndef来避免。
>&emsp;&emsp;#ifndef起到的效果是防止一个源文件两次包含同一个头文件，而不是防止两个源文件包含同一个头文件。事实上，防止同一头文件被两个不同的源文件包含这种要求本身就是不合理的，头文件存在的价值就是被不同的源文件包含。也就是说对于A.cpp和B.cpp两个源文件都包含了head.h的头文件时，条件编译不会起到作用。这也就意味着如果头文件中定义了类外的函数或者全局变量，那么当多个源文件同时包含这一头文件时，会发生重复定义的错误。
>&emsp;&emsp;为了避免重复定义，一般头文件中不会存放定义，只存放函数声明和变量的声明。但也有例外，类、inline函数和编译时值已知的const对象可以在头文件中定义，这是因为遵守“单一定义规则”(One-Definition Rule, ODR)。根据此规则， 如果对同一个类的两个定义完全相同且出现在不同编译单位，会被当作同一个定义。当包含类的头文件分别被两个不同的编译单位（file1.cpp, file2.cpp）包含，满足ODR规则，会被当作同一个定义，所以不会有冲突。此外，模板和inline函数也适用此规则。

2. 搜索了“makefile 调试开关”的格式，之前以为debug的值是makefile通过读入得到的，看来并非如此。

ifeq (, True)
/bin/sh: 1: Syntax error: word unexpected (expecting ")")

* **Task 2**

Makefile:3: *** missing separator.  Stop.
(.text+0x20): undefined reference to `main`

g++ A.cpp -o
g++: error: missing filename after ‘-o’

g++ -lA -LA -lB -LB -lC -LC main.cpp -o main
/tmp/ccAV1oIr.o: In function `main`:
main.cpp:(.text+0x5): undefined reference to `A()`



* **Task 3**

./main: error while loading shared libraries: libE.so: cannot open shared object file: No such file or directory

LD_PRELOAD

* **Task 4**

* **Task 5(H)**
