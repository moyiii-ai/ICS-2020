# ICSⅠ Lab5 报告

计算机科学与技术
19307130296
孙若诗

## eval

功能为对用户输入的命令行解析并运行计算，对内置指令立即执行，否则fork一个子进程执行。基本框架已经在课本上给出，只需要完善进程阻塞和具体处理即可。

- 首先定义所需变量，初始化阻塞信号集合，将SIGCHLD加入mask_one，将所有信号加入mask_all

- 调用parseline解析cmdline

- 调用builtin_cmd检查第一个命令行参数是否是一个内置的shell指令。如果是，指令直接在builtin_cmd函数内被解释完成，eval的工作结束

- 如果不是，需要创建一个子进程来执行请求的程序    
    - 由于要在此进程addjob，因此要先阻塞SIGCHLD防止竞争
    - fork()返回0说明这是子进程，使用setpgid创建一个新的进程组，解除进程阻塞，使用execve执行cmdline，无可执行文件则打印信息退出
    - 接下来要修改jobs相关的全局变量，因此先阻塞所有信号，再addjob
    - 如果用户要求cmdline前台执行，则调用waitfg等候子进程结束
    - 如果用户要求后台执行，使用getjobpid函数获取任务信息，按rtest给出的格式打印
    - 处理结束，解除阻塞

## builtin_cmd

功能为判断输入指令是否为内置shell指令，是则立即解释并返回1，否则返回0，类似一个cmdline分类器。课本上同样给出了基本实现，只要再增加几种情况即可。

shell lab中的shell内置的命令包括quit、jobs、bg、fg。

- 如果argv[0]为quit，直接退出

- 如果argv[0]为jobs，按要求调用listjobs打印所有jobs信息，返回1

- 如果argv[0]为bg或fg，调用do_bgfg处理，返回1

- 如果argv[0]不满足上述情况，返回0

## do_bgfg

功能为执行bg和fg指令。

## waitfg

功能为等待前台程序运行结束。参数为pid，即当前监控的进程。

- 由于jobs为全局变量，查询之前先阻塞所有信号，查询后再解除。

- 调用fgpid，其功能为返回目前前台运行的进程id，如果没有前台进程返回0。waitfg的目标即为pid等于fgpid时保持休眠。

- 休眠用sigsupend实现，创建一个空的阻塞信号集合，在捕捉到信号之前将进程挂起

## sigchld_handler

功能为响应SIGCHLD信号。

- 首先按照课本上的安全信号处理原则，将errno记录，退出函数之前还原errno

- 调用waitpid函数，使用WNOHANG | WUNTRACED参数，立即返回，如果等待集合中的子进程都没有停止或终止，返回0；如果有一个被停止或终止，返回该子进程的pid

- 如果pid大于0，说明有停止或终止的子进程，可以从statusp获取相关信息

- 调用WIFSTOPPED，如果子进程被停止返回1，用getjobpid获取作业信息、WSTOPSIG获取引起子进程停止的信息编号，并打印。

- 否则子进程是终止的
    - 调用WIFSIGNALED，如果子进程是因为一个未被捕获的信号终止的返回1，用WTERMSIG获取导致子进程终止的信息编号并打印
    - 从作业列表中删除该子进程

- 查询后阻塞信号，以备deletejob修改全局变量，处理结束后解除阻塞

## sigint_handler

功能为响应SIGINT(Ctrl+C)。

- 记录和还原errno

- 使用fgpid查询当前在前台执行的进程。由于fgpid涉及到全局变量，照例阻塞所有信号，查询后再解除

- 如果当前有前台进程，使用kill对该进程所在的进程组发送SIGINT信号，要求进程终止。

## sigtstp_handler

功能为响应SIGTSTP(Ctrl+Z)，除kill发送的信息改为SIGTSTP之外均和sigint_handler相同，意为使进程停止直到下一个SIGCONT。